#!/usr/bin/env python3
"""
~/bin/renamePrefixWithInitials.py
  Renames files in a directory prepending their names them with a "prefix" generated by the following rule:

  1) if only one word exists at the beginning of filename, the prefix is composed of its 2-initial letters Capitalized
  2) if two words can be drawn from filename:
     then the Capitalized prefix is composed of the first letter of first word
     and the first letter of second word.

Examples:

  1 "Buddha.mp4" becomes "BU Buddha.mp4"
  2 "Albert Einstein.mp4" becomes "AE Albert Einstein.mp4"
     or, if lowercase, "albert einstein.mp4" becomes "AE albert einstein.mp4"

Exception:

  If a name starts with 2 Capital letters followed by a space,
    then its filename will not be considered for rename.

Usage:
  renamePrefixWithInitials.py [-e=<ext>] [-y]

Where:
  -e=<ext> | optional | defines the file extension of the files to be renamed,
    if None (absent), all files are considered
  -y | optional | does autoconfirmation if renames are formed (if missing, a user-confirmation is asked)

Example:
  renamePrefixWithInitials.py -e=mp4
    This is considered for prefix-rename all files having the mp4 extension

"""
import string
from pathlib import Path
import glob
import os
import sys  # shutil, sys


def get_prefix_depending_on_words(name):
  if name is None:
    return None
  if len(name) < 2:
    return None
  # keep a preliminar one-word prefix, try next the prefix with 2 words, if not possible, return this preliminar
  prefix = name[:2].upper()
  try:
    phrase = name.split('-')[0]
    twowords = phrase.split(' ')[0:2]
    letter1 = twowords[0][0].upper()
    letter2 = twowords[1][0].upper()
    prefix = letter1 + letter2
    return prefix
  except (AttributeError, IndexError):
    pass
  return prefix


def avoid_filename_if_shortname_or_already_prefixed(filename: str | None) -> bool:
  if filename is None:
    return True
  if len(filename) < 2:
    # too short a name
    return True
  try:
    first2letters = filename[0:2]
    capital_letters = list(filter(lambda c: c in string.ascii_uppercase, first2letters))
    if len(capital_letters) == len(first2letters):
      # at here the two first letters are capitalized (upper case)
      if filename[2] == ' ':
        # at here there is a gap in the 3rd position, following the 2 first Caps
        return True
  except IndexError:
    # if IndexError happened, avoid renaming it too
    return True
  return False


class InitialsPrefixRenamer:
  """
  This class processes the renaming logics. It works as a job-chain, ie each method prepares a part of the whole.
    Take a look at method process() to observe the pieces in the job-chain.
  """

  def __init__(self, dot_extension=None, working_dir_ap=None, autorename_without_confirmation=False):
    self.dot_extension = dot_extension
    self.working_dir_ap = working_dir_ap
    self.treat_extension_n_workdir()
    self.rename_pairs = []
    self.autorename_without_confirmation = autorename_without_confirmation
    # self.process_renames()

  def treat_extension_n_workdir(self):
    """
    if dot_extension is None, this means "get all files in folders"
    """
    self.treat_extension()
    self.treat_working_dir()

  def treat_extension(self):
    if self.dot_extension is None:
      return
    self.dot_extension = self.dot_extension.lstrip(' \t').rstrip(' \t\r\n')
    if len(self.dot_extension) == 0:
      self.dot_extension = None
    if not self.dot_extension.startswith('.'):
      self.dot_extension = '.' + self.dot_extension

  def treat_working_dir(self):
    if self.working_dir_ap is None or not os.path.isdir(self.working_dir_ap):
      self.working_dir_ap = os.getcwd()
    # make it type pathlib.Path
    self.working_dir_ap = Path(self.working_dir_ap)

  def prep_renames(self):
    if self.dot_extension is None:
      files = os.listdir(self.working_dir_ap)
    else:
      mask = '*' + self.dot_extension
      files = glob.glob(mask, root_dir=self.working_dir_ap)
    if len(files) == 0:
      print('No files to rename.')
      return
    foundfilenames = [os.path.split(f)[1] for f in files]
    foundfilenames = sorted(foundfilenames)
    filenames = []
    for filename in foundfilenames:
      if avoid_filename_if_shortname_or_already_prefixed(filename):
        continue
      filenames.append(filename)
      filenames.append(filename)
    zfillsize = len(str(len(filenames)))
    for i, filename in enumerate(filenames):
      prefix = get_prefix_depending_on_words(filename)
      new_filename = f"{prefix} {filename}"
      pair = (filename, new_filename)
      self.rename_pairs.append(pair)
      seq = i + 1
      sseq = str(seq).zfill(zfillsize)
      scrmsg = f"{sseq} Renaming:"
      print(scrmsg)
      scrmsg = f"\tFrom: [{filename}]"
      print(scrmsg)
      scrmsg = f"\tTo:   [{new_filename}]"
      print(scrmsg)

  def confirm_renames(self):
    if len(self.rename_pairs) == 0:
      return False
    total_files = len(self.rename_pairs)
    print('total_files', total_files)
    ans = input('Are you sure? (*Y/n) ')
    if ans in ['y', 'Y', '']:
      return True
    return False

  def do_renames(self):
    if len(self.rename_pairs) == 0:
      return
    total_files = len(self.rename_pairs)
    n_renames = 0
    zfillsize = len(str(total_files))
    for i, pair in enumerate(self.rename_pairs):
      filename, new_filename = pair
      if not os.path.isfile(filename):
        print('File [' + filename + '] does not exist.')
        continue
      if os.path.isfile(new_filename):
        print('File [' + filename + '] already exists.')
        continue
      seq = i + 1
      sseq = str(seq).zfill(zfillsize)
      scrmsg = f"{sseq} Renaming @ [{self.working_dir_ap}]"
      print(scrmsg)
      scrmsg = f"\tFrom: [{filename}]"
      print(scrmsg)
      scrmsg = f"\tTo:   [{new_filename}]"
      print(scrmsg)
      srcfile = self.working_dir_ap / filename
      trgfile = self.working_dir_ap / new_filename
      os.rename(srcfile, trgfile)
      n_renames += 1
    scrmsg = f"n_renames = {n_renames} | total_files = {total_files}"
    print(scrmsg)

  def process_renames(self):
    self.prep_renames()
    if self.autorename_without_confirmation:
      self.do_renames()
    else:
      if self.confirm_renames():
          self.do_renames()


def get_args():
  """
  Gets the parameter arguments from the command line
  :return prefix, extension:
  """
  extension, dirpath, autorename_without_confirmation = None, None, False
  if len(sys.argv) > 1:
    for arg in sys.argv[1:]:
      if arg in ['-h', '--help']:
        print(__doc__)
        sys.exit(0)
      elif arg.startswith('-e='):
        extension = arg[len('-e='):]
      elif arg.startswith('-dp='):
        dirpath = arg[len('-dp='):]
      elif arg == '-y':
        autorename_without_confirmation = True
  return extension, dirpath, autorename_without_confirmation


def process():
  extension, dirpath, autorename_without_confirmation = get_args()
  scrmsg = (f"extension={extension} | dirpath = {dirpath}"
            f" | autorename_without_confirmation={autorename_without_confirmation}")
  print(scrmsg)
  renamer = InitialsPrefixRenamer(
    dot_extension=extension, working_dir_ap=dirpath, autorename_without_confirmation=autorename_without_confirmation
  )
  renamer.process_renames()


if __name__ == '__main__':
  process()
